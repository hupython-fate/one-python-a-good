#一，json,是一种通用的数据格式，也就是数据的储存格式。
#几乎所有的现代网站都用json来存数据，在爬虫中，我们爬取到的数据往往是json形式的。而不是html源代码。
#json库就是用来序列化和反序列化的。
#将 Python对象（字典/列表） 转换成 JSON格式字符串是序列化。json.dumps()
#将 JSON格式字符串 解析成 Python对象（字典/列表）是反序列化。（收到数据后读取）json.loads()
import json
kkk={1:123456789,2:222,3:['黑色']}
x=json.dumps(kkk)#序列化,把字典转化为字符串。
print(type(x))
print(x)
print(kkk)

y=json.loads(x)#反序列化，把json字符串转化为字典或列表。
print(type(y))
print(y)
'''认知负荷优化提示：在爬虫中，我们从网上请求到的数据通常是JSON字符串，
我们必须用 json.loads() 把它变成Python字典，才能从中提取我们需要的信息。
几乎所有现代API都返回JSON数据。'''

#二，os - 操作系统的“遥控器”
import os
#os模块提供了大量函数，让你能与操作系统（Windows, Mac, Linux） 交互，比如操作文件和目录。

c=os.getcwd()#获取当前路径。
print(f'当前路径是：{c}')


fff='一个文件名，嗯，随便想的。'
hh=os.path.join(c,fff)#拼接路径
# (非常重要，能避免不同操作系统路径分隔符\和/的问题)
print(f'准备创建的目录路径是：{hh}')


if os.path.exists(c):
    print('这个路径存在。')
#检查路径是否存在：

'''os.makedirs()'''#创建目录。如果创建的文件已经存在，就会报错。
print(f'建创的目录为：{hh}')




import re
#三，re - 文本中的“模式侦探”
#正则表达式是用来匹配和处理字符串的强大工具。它通过一些特殊符号定义了一套规则，用来在文本中查找、提取、替换符合规则的字符串。
#这是三个模块中最难但也最强大的一个，我们只学基础，建立初步感觉。

'''先只学三个最基础的元字符'''
#. (点)：匹配任意一个字符（除了换行符）
#\d：匹配任意一个数字。等价于[0-9]。
#+：匹配前面的字符1次或多次
#核心函数：re.findall(pattern, string) - 在字符串中找到所有匹配的模式，并以列表形式返回。
ccc="我的幸运数字是9526-555-555."
x=r'\d'
g=re.findall(x,ccc)#第一个参数是模式，第二个参数是要匹配的文本数据。
print(f'找到的数据是（不连续的数字）：{g}')#找出的是数据里所有与模式匹配的数据。

x1=r'\d+'
f=re.findall(x1,ccc)
print(f'找到的数据是（连续的数字）：{f}')

x2=r"\d+\-\d+\-\d+"#d+代表的是连续的字符，\-\代表连序字符中的连字符，这个模式中有三个d+,代表着三个连续字符，三个连续字符中有两个-，代表着三个连续字符中的连字符。
g=re.findall(x2,ccc)
print(f'找到的数据是（带练字符的数字）：{g}')

#比如说，
x='我的电话号码是123-4567-7899'
#利用re就能提取出我的电话号码了。
#操作如下：
x3=r'\d+\-\d+\-\d+'#先定义自己要提取的数据的模式，“\d”代表一个数字，"\-"代表一个连字符，“\d+”代表一个连续的数字。
u=re.findall(x3,x)#再调用re库中的findall函数，再用一个变量储存提取到的匹配到的数据。#返回的是一个列表。
print(u)#再把提取到的数据打印出来就行了。

'''认知负荷优化提示：
在爬虫解析数据时，
当标准解析器（如XPath）无法有效定位一小段特定信息（如一串数字、一个邮箱）时，正则表达式就是你的终极武器。
初期不必深究所有复杂规则，掌握\d, \w（字母数字下划线）, ., *, +, ? 这几个就解决了80%的问题。'''

#对re的再尝试：

x4=r'.*'#匹配任意一个字符
llll=re.findall(x4,x)
print(llll)


x5=r'电'#匹配普通字符
asd=re.findall(x5,x)
print(asd)

'''从deepseek复制的测试代码'''

# 我们的测试字符串列表
test_strings = ["A", "AB", "ABB", "AC", "A1", "A_", "Hello"]

# 定义我们要测试的所有模式
patterns = {
    "AB*": r"AB*",   # A后面跟0个或多个B
    "AB+": r"AB+",   # A后面跟1个或多个B
    "AB?": r"AB?",   # A后面跟0个或1个B
    "A\w*": r"A\w*", # A后面跟0个或多个单词字符
    "\w+": r"\w+",   # 1个或多个单词字符（匹配整个单词）
}

print("让我们来验证一下可视化图表的理解：\n")

for pattern_name, pattern in patterns.items():
    print(f"模式 '{pattern_name}' 的结果:")
    for text in test_strings:
        matches = re.findall(pattern, text)
        if matches: # 如果匹配到了，就打印出来
            print(f"  '{text}' -> {matches}")
    print("-" * 30)



#我自己举一个例子吧。
#今天先学会*+？这三个量词。

pp='弃我去者，昨日之日不可留;\n乱我心者，今日之日多烦忧。\n长风万里送秋雁，对此可以酣高楼。\n蓬莱文章建安骨，中间小谢又清发。\n俱怀逸兴壮思飞，欲上青天览明月。\n抽刀断水水更流，举杯消愁愁更愁。\n人生在世不称意，明朝散发弄扁舟。注：李白者，逍遥者也。'
x6=r'者'
sdf=re.findall(x6,pp)#re.findall()方法的第二个参数必须是string.
print(sdf)
#x6是单纯的普通子符，匹配出了四个“者”字。
x7=r'者+'
sdf=re.findall(x7,pp)
print(sdf)
#x7是普通字符加“+”，匹配出了四个“者”字。
x8=r'者*'
sdf=re.findall(x8,pp)
print(sdf)
#x8是普通字符加“*”，不仅匹配出了四个“者”字，还匹配出了每个其它字符——用空格的形式。
#嗯，deepseek上写：星号	匹配前面的字符0次或多次（可有可无，可以有任意个）  	“任意次”
#还有：AB*：匹配"A"，后面跟0个或多个"B"     #也就是说，r'者*'实际上匹配的是空格，空格后面跟零个或多个“者”？
#这是什么意思？
x9=r'者?'
sdf=re.findall(x9,pp)
print(sdf)
#x9是普通字符加“?”,输出和x8一样，为什么会这样？

'''
#问题的解答：
2. 案例 x8 = r'者*'（这是困惑的来源）
模式：'者*'

行为：寻找 “0个或多个「者」”。

* 量词允许匹配“空字符串”（即0次）！

匹配过程：引擎从字符串第一个字符开始尝试匹配：

位置 "弃"：这里没有“者”，但 '者*' 允许匹配0个“者”。所以，它在这里匹配上了一个空字符串 ''！

位置 "我"：同样，没有“者”，再次匹配上一个空字符串 ''。

位置 "去"：同样，匹配上一个空字符串 ''。

位置 "者"：这里有“者”，'者*' 匹配上了 "者"。

结果：['', '', '', '者']。因为你打印出来了，所以你会看到：['', '', '', '者']，其中的空字符串在打印时显示为“空”，但它们是真实存在的匹配项。

这解释了为什么你的输出看起来有很多“空格”，它们其实是 findall 找到的无数个空字符串匹配！

3. 案例 x9 = r'者?'
模式：'者?'

行为：寻找 “0个或1个「者」”。它同样允许匹配空字符串！

匹配过程：和 '者*' 几乎一模一样，在每个不是“者”的字符位置，它都匹配上一个空字符串 ''。在“者”的位置，它匹配上 "者"。

结果：和 '者*' 一样，也是 ['', '', '','者']


💡 如何得到你“预期”的结果？
你真正的预期可能是：“找到所有包含‘者’的词语”。那么，'者*' 和 '者?' 就不是正确的工具。

正确的工具是：使用能匹配“一个或多个非‘者’字符 + ‘者’”的模式。

例如，如果你想匹配“X者”这样的两个字：

python
x10 = r'\w者'  # 匹配一个单词字符后面跟着一个“者”
sdf = re.findall(x10, pp)
print(sdf)  # 输出：['去者', '心者', '李者']? 好像不对， “李者”不是词
更精准的做法是匹配任意非换行符（因为诗句用换行分隔）：

python
x11 = r'.者'  # 匹配任意一个字符（换行符除外）后面跟着一个“者”
sdf = re.findall(x11, pp)
print(sdf)  # 输出：['去者', '心者', '白者'] 
但这样还是不准。最好的方法是使用 + 来匹配你真正想要的主体：

python
# 匹配：1个或多个（单词字符或逗号等） + “者”
x12 = r'\w+者'
sdf = re.findall(x12, pp)
print(sdf)  # 输出：['去者', '心者', '李白者']
总结与认知负荷优化
核心误区：* 和 ? 允许匹配空字符串。而 findall 会忠实返回每一个匹配，包括所有这些空字符串。

降负荷策略：

明确目标：先想清楚你到底想匹配“什么”（是单个字，还是一个词？）。

选择工具：

匹配确定内容用普通字符（r'者'）。

匹配不确定但必须存在的内容用 +（r'\w+者'）。

谨慎使用 * 和 ?，除非你确实需要处理“可能不存在”的情况。

你现在不是“困惑”，而是“发现了关键问题”。这是深度学习过程中的一个里程碑！


'''


#*是匹配零次或多次，
#+是匹配一次或多次，
#?是匹配一次或零次。


#实战演练
yi_duan_xin_xi='我的特价商品是666元，打折了3.3。'

x10=r'\d+元\d+\.\d'
zxc=re.findall(x10,yi_duan_xin_xi)
print(zxc)

#为什么是空的？如果x10是r'\d+元',那么会输出100元，如果是r'\d+\.\d',那么就输出3.3元，但是加起来就输出的是空格。

'''核心问题：正则表达式是“连续匹配”的
关键原理：默认情况下，正则表达式期望你的模式在目标字符串中作为一个连续的整体出现。

让我们来分解你的代码：

你的字符串：'我的特价商品是666元，打折了3.3。'

你的模式：r'\d+元\d+\.\d'

这个模式的意思是：寻找一串数字，后面紧跟着“元”字，后面再紧跟着一串数字，后面再紧跟着一个小数点，后面再紧跟着一个数字。


看到问题了吗？你的模式要求 元 和 3.3 必须紧挨着，但实际字符串中，它们之间隔着 “，打折了” 这几个字符。所以整个匹配失败了。'''

#第一个解决方案，使用通配。

yi_duan_xin_xi='我的特价商品是666元，打折了3.3。'

x10=r'\d+元.*?\d+\.\d'   #     .*?     表示中间的任意内容。
zxc=re.findall(x10,yi_duan_xin_xi)
print(zxc)#输出结果为['666元，打折了3.3']

#第二个解决方案，使用分组（）。

yi_duan_xin_xi='我的特价商品是666元，打折了3.3。'

x10=r'(\d+元).*?(\d+\.\d)'
zxc=re.findall(x10,yi_duan_xin_xi)
print(zxc)#输出结果为[('666元', '3.3')]


'''从deepseek上复制下来的演试：
'''

# 假设这是你爬取到的原始文本
messy_text = "这个商品售价100元，另一个特价品88元，还有一个9.5元的优惠品。"

# 我们一起来设计正则表达式
# 目标：匹配【数字（可能包含小数点）】+【“元”】
# 第一步：匹配数字（可能包含小数点） -> 用字符集 \d 和 .
# 第二步：确保它后面紧跟着“元”字

pattern = r"\d+\.?\d*元"  # 我们来一步步解读这个模式

print("提取到的价格有：")
prices = re.findall(pattern, messy_text)
for price in prices:
    print(price)
